[0_int&double]////////////////////////////////////
#include <stdio.h>
int main(int argc, char const *argv[])
{
	double aDouble = 1/3;
	printf("%lf\n", aDouble);
	return 0;
}
这段代码输出的是：0.000000
因为1和3默认为int类型，1/3=0，即使左边定义的是double类型，也只会把整型的0隐式转换为double型的0.000000

在calculatePi.c中，我最初把n定义为int类型，结果deltaAbsolute就一直是0.000000

[1_minus]/////////////////////////////////////
//利用Taylor展开求pi
#include <stdio.h>
#include <math.h>
int main()
{
    //tmp = pi/4
    double pi = 0.0;
    double tmp = 1.0;
    double delta = 1.0;
    double deltaAbsolute = 1.0;
    double n = 1;
    double minus = -1;		
    while(deltaAbsolute>0.000001){
        n += 2;
        deltaAbsolute = 1/n;
        delta = minus*deltaAbsolute;
        //minus *= (-1);
        minus *= minus;
        //如果这样对minus进行操作，从第二次循环开始，minus就一直是+1
        //所以输出一个大于pi的值
        tmp += delta;
        pi = tmp * 4;
        
    }
    printf("pi is %lf\n", pi);
    printf("pi/4 is %lf\n", tmp);
    return 0;
}

